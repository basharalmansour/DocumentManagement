/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.14.4.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface ICondolifeClient {
    getSites(request: GetSitesRequestDto): Observable<FileResponse>;
    getSiteDetails(siteId: string): Observable<FileResponse>;
    getZones(request: GetZonesRequestDto): Observable<FileResponse>;
    getZoneDetails(zoneId: string): Observable<FileResponse>;
    getBlocks(searchText: string): Observable<FileResponse>;
    getBlockDetails(blockId: string): Observable<FileResponse>;
    getUnits(request: GetUnitsRequestDto): Observable<FileResponse>;
    getUnitDetails(unitId: number): Observable<FileResponse>;
    getAreas(request: GetAreasRequestDto): Observable<FileResponse>;
    getAreaDetails(areaId: number): Observable<FileResponse>;
    getCompanies(request: GetCompaniesRequestDto): Observable<FileResponse>;
    getCompanyDetails(companyId: number): Observable<FileResponse>;
    getBrands(request: GetBrandsRequestDto): Observable<FileResponse>;
    getBrandDetails(brandId: number): Observable<FileResponse>;
    getDepartments(request: GetDepartmentsRequestDto): Observable<FileResponse>;
    getPersonnels(request: GetPersonnelsRequestDto): Observable<FileResponse>;
    getPersonnelDetails(personnelId: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class CondolifeClient implements ICondolifeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getSites(request: GetSitesRequestDto) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Condolife/GetSitesAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSites(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSites(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetSites(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getSiteDetails(siteId: string) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Condolife/GetSiteDetailsAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(siteId);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSiteDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSiteDetails(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetSiteDetails(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getZones(request: GetZonesRequestDto) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Condolife/GetZonesAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetZones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetZones(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetZones(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getZoneDetails(zoneId: string) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Condolife/GetZoneDetailsAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(zoneId);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetZoneDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetZoneDetails(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetZoneDetails(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getBlocks(searchText: string) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Condolife/GetBlocksAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(searchText);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBlocks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBlocks(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetBlocks(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getBlockDetails(blockId: string) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Condolife/GetBlockDetailsAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(blockId);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBlockDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBlockDetails(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetBlockDetails(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getUnits(request: GetUnitsRequestDto) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Condolife/GetUnitsAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnits(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnits(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getUnitDetails(unitId: number) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Condolife/GetUnitDetailsAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(unitId);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnitDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnitDetails(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnitDetails(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getAreas(request: GetAreasRequestDto) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Condolife/GetAreasAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAreas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAreas(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetAreas(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getAreaDetails(areaId: number) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Condolife/GetAreaDetailsAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(areaId);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAreaDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAreaDetails(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetAreaDetails(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getCompanies(request: GetCompaniesRequestDto) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Condolife/GetCompaniesAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompanies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompanies(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetCompanies(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getCompanyDetails(companyId: number) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Condolife/GetCompanyDetailsAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(companyId);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompanyDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompanyDetails(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetCompanyDetails(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getBrands(request: GetBrandsRequestDto) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Condolife/GetBrandsAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrands(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrands(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrands(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getBrandDetails(brandId: number) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Condolife/GetBrandDetailsAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(brandId);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrandDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrandDetails(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrandDetails(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getDepartments(request: GetDepartmentsRequestDto) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Condolife/GetDepartmentsAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepartments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepartments(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetDepartments(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getPersonnels(request: GetPersonnelsRequestDto) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Condolife/GetPersonnelsAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPersonnels(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPersonnels(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetPersonnels(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getPersonnelDetails(personnelId: number) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Condolife/GetPersonnelDetailsAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(personnelId);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPersonnelDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPersonnelDetails(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetPersonnelDetails(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface ICustomerClient {
    sendOtp(sendOtpToCustomerCommand: SendOtpToCustomerCommand): Observable<SendOtpMessageResult>;
}

@Injectable({
    providedIn: 'root'
})
export class CustomerClient implements ICustomerClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    sendOtp(sendOtpToCustomerCommand: SendOtpToCustomerCommand) : Observable<SendOtpMessageResult> {
        let url_ = this.baseUrl + "/api/Customer/SendOtpMessage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sendOtpToCustomerCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendOtp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendOtp(<any>response_);
                } catch (e) {
                    return <Observable<SendOtpMessageResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SendOtpMessageResult>><any>_observableThrow(response_);
        }));
    }

    protected processSendOtp(response: HttpResponseBase): Observable<SendOtpMessageResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SendOtpMessageResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorResponseModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SendOtpMessageResult>(<any>null);
    }
}

export interface IVehicleClient {
    createVehicle(request: CreateVehicleTemplateCommand): Observable<ApplicationResponse>;
    getVehicles(request: GetVehicleTemplateQuery | null | undefined): Observable<ApplicationResponse>;
    getVehicleById(id: number | undefined): Observable<ApplicationResponse>;
    editVehicle(request: EditVehicleTemplateCommand): Observable<ApplicationResponse>;
    removeVehicle(request: RemoveVehicleTemplateCommand): Observable<ApplicationResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class VehicleClient implements IVehicleClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createVehicle(request: CreateVehicleTemplateCommand) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/Vehicle/CreateVehicle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateVehicle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateVehicle(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreateVehicle(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    getVehicles(request: GetVehicleTemplateQuery | null | undefined) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/Vehicle/GetVehicles?";
        if (request !== undefined && request !== null)
            url_ += "request=" + encodeURIComponent("" + request) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVehicles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVehicles(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetVehicles(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    getVehicleById(id: number | undefined) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/Vehicle/GetVehicle?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVehicleById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVehicleById(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetVehicleById(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    editVehicle(request: EditVehicleTemplateCommand) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/Vehicle/EditVehicle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditVehicle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditVehicle(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processEditVehicle(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    removeVehicle(request: RemoveVehicleTemplateCommand) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/Vehicle/RemoveVehicle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveVehicle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveVehicle(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveVehicle(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }
}

export interface IUserGroupClient {
    createUserGroup(request: CreateUserGroupCommand): Observable<ApplicationResponse>;
    getUserGroups(searchText: string | null | undefined): Observable<ApplicationResponse>;
    getUserGroupById(id: number | undefined): Observable<ApplicationResponse>;
    editUserGroup(request: EditUserGroupCommand): Observable<ApplicationResponse>;
    deleteUserGroup(request: RemoveUserGroupCommand): Observable<ApplicationResponse>;
    getUserGroupApprovers(id: number | undefined): Observable<ApplicationResponse>;
    getPersonnelRoles(personnelId: number | undefined): Observable<ApplicationResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class UserGroupClient implements IUserGroupClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createUserGroup(request: CreateUserGroupCommand) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/UserGroup/CreateUserGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUserGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUserGroup(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUserGroup(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    getUserGroups(searchText: string | null | undefined) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/UserGroup/GetUserGroups?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserGroups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserGroups(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserGroups(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    getUserGroupById(id: number | undefined) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/UserGroup/GetUserGroupById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserGroupById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserGroupById(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserGroupById(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    editUserGroup(request: EditUserGroupCommand) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/UserGroup/EditUserGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditUserGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditUserGroup(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processEditUserGroup(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    deleteUserGroup(request: RemoveUserGroupCommand) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/UserGroup/DeleteUserGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserGroup(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUserGroup(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    getUserGroupApprovers(id: number | undefined) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/UserGroup/GetUserGroupApprovers?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserGroupApprovers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserGroupApprovers(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserGroupApprovers(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    getPersonnelRoles(personnelId: number | undefined) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/UserGroup/GetPersonnelRoles?";
        if (personnelId === null)
            throw new Error("The parameter 'personnelId' cannot be null.");
        else if (personnelId !== undefined)
            url_ += "PersonnelId=" + encodeURIComponent("" + personnelId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPersonnelRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPersonnelRoles(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetPersonnelRoles(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }
}

export interface IServiceCategoryClient {
    createServiceCategory(request: CreateServiceCategoryCommand): Observable<ApplicationResponse>;
    getServiceCategories(searchText: string | null | undefined): Observable<ApplicationResponse>;
    getServiceCategoryById(id: number | undefined): Observable<ApplicationResponse>;
    editServiceCategory(request: EditServiceCategoryCommand): Observable<ApplicationResponse>;
    deleteServiceCategory(request: RemoveServiceCategoryCommand): Observable<ApplicationResponse>;
    getPersonnelCategories(presonnelId: number | undefined): Observable<ApplicationResponse>;
    getPersonnelRoles(personnelId: number | undefined): Observable<ApplicationResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ServiceCategoryClient implements IServiceCategoryClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createServiceCategory(request: CreateServiceCategoryCommand) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/ServiceCategory/CreateServiceCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateServiceCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateServiceCategory(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreateServiceCategory(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    getServiceCategories(searchText: string | null | undefined) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/ServiceCategory/ViewServiceCategories?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetServiceCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetServiceCategories(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetServiceCategories(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    getServiceCategoryById(id: number | undefined) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/ServiceCategory/ViewServiceCategoryById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetServiceCategoryById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetServiceCategoryById(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetServiceCategoryById(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    editServiceCategory(request: EditServiceCategoryCommand) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/ServiceCategory/EditServiceCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditServiceCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditServiceCategory(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processEditServiceCategory(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    deleteServiceCategory(request: RemoveServiceCategoryCommand) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/ServiceCategory/DeleteServiceCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteServiceCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteServiceCategory(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteServiceCategory(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    getPersonnelCategories(presonnelId: number | undefined) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/ServiceCategory/GetPersonnelCategories?";
        if (presonnelId === null)
            throw new Error("The parameter 'presonnelId' cannot be null.");
        else if (presonnelId !== undefined)
            url_ += "PresonnelId=" + encodeURIComponent("" + presonnelId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPersonnelCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPersonnelCategories(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetPersonnelCategories(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    getPersonnelRoles(personnelId: number | undefined) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/ServiceCategory/GetPersonnelRoles?";
        if (personnelId === null)
            throw new Error("The parameter 'personnelId' cannot be null.");
        else if (personnelId !== undefined)
            url_ += "PersonnelId=" + encodeURIComponent("" + personnelId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPersonnelRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPersonnelRoles(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetPersonnelRoles(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }
}

export interface IPersonnelClient {
    getAllApprovers(roles: Role[] | null | undefined, searchText: string | null | undefined, departmentId: number | undefined): Observable<ApplicationResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class PersonnelClient implements IPersonnelClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAllApprovers(roles: Role[] | null | undefined, searchText: string | null | undefined, departmentId: number | undefined) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/Personnel/GetAllApprovers?";
        if (roles !== undefined && roles !== null)
            roles && roles.forEach(item => { url_ += "Roles=" + encodeURIComponent("" + item) + "&"; });
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (departmentId === null)
            throw new Error("The parameter 'departmentId' cannot be null.");
        else if (departmentId !== undefined)
            url_ += "DepartmentId=" + encodeURIComponent("" + departmentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllApprovers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllApprovers(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllApprovers(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }
}

export interface IPresenceClient {
    getAreaDocuments(request: GetAreaDocumentsQuery): Observable<ApplicationResponse>;
    getBlockDocuments(request: GetBlockDocumentsQuery): Observable<ApplicationResponse>;
    getBrandDocuments(request: GetBrandDocumentsQuery): Observable<ApplicationResponse>;
    getCompanyDocuments(request: GetCompanyDocumentsQuery): Observable<ApplicationResponse>;
    getSiteDocuments(request: GetSiteDocumentsQuery): Observable<ApplicationResponse>;
    getUnitDocuments(request: GetUnitDocumentsQuery): Observable<ApplicationResponse>;
    getZoneDocuments(request: GetZoneDocumentsQuery): Observable<ApplicationResponse>;
    createAreaDocuments(request: CreateAreaDocumentsCommand): Observable<ApplicationResponse>;
    createBlockDocuments(request: CreateBlockDocumentsCommand): Observable<ApplicationResponse>;
    createBrandDocuments(request: CreateBrandDocumentsCommand): Observable<ApplicationResponse>;
    createCompanyDocuments(request: CreateCompanyDocumentsCommand): Observable<ApplicationResponse>;
    createSiteDocuments(request: CreateSiteDocumentsCommand): Observable<ApplicationResponse>;
    createUnitDocuments(request: CreateUnitDocumentsCommand): Observable<ApplicationResponse>;
    createZoneDocuments(request: CreateZoneDocumentsCommand): Observable<ApplicationResponse>;
    removeAreaDocuments(request: RemoveAreaDocumentsCommand): Observable<ApplicationResponse>;
    removeBlockDocuments(request: RemoveBlockDocumentsCommand): Observable<ApplicationResponse>;
    removeBrandDocuments(request: RemoveBrandDocumentsCommand): Observable<ApplicationResponse>;
    removeCompanyDocuments(request: RemoveCompanyDocumentsCommand): Observable<ApplicationResponse>;
    removeSiteDocuments(request: RemoveSiteDocumentsCommand): Observable<ApplicationResponse>;
    removeUnitDocuments(request: RemoveUnitDocumentsCommand): Observable<ApplicationResponse>;
    removeZoneDocuments(request: RemoveZoneDocumentsCommand): Observable<ApplicationResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class PresenceClient implements IPresenceClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAreaDocuments(request: GetAreaDocumentsQuery) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/Presence/GetAreaDocuments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAreaDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAreaDocuments(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetAreaDocuments(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    getBlockDocuments(request: GetBlockDocumentsQuery) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/Presence/GetBlockDocuments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBlockDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBlockDocuments(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetBlockDocuments(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    getBrandDocuments(request: GetBrandDocumentsQuery) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/Presence/GetBrandDocuments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrandDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrandDocuments(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrandDocuments(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    getCompanyDocuments(request: GetCompanyDocumentsQuery) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/Presence/GetCompanyDocuments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompanyDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompanyDocuments(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetCompanyDocuments(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    getSiteDocuments(request: GetSiteDocumentsQuery) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/Presence/GetSiteDocuments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSiteDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSiteDocuments(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetSiteDocuments(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    getUnitDocuments(request: GetUnitDocumentsQuery) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/Presence/GetUnitDocuments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnitDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnitDocuments(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnitDocuments(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    getZoneDocuments(request: GetZoneDocumentsQuery) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/Presence/GetZoneDocuments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetZoneDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetZoneDocuments(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetZoneDocuments(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    createAreaDocuments(request: CreateAreaDocumentsCommand) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/Presence/CreateAreaDocuments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAreaDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAreaDocuments(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAreaDocuments(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    createBlockDocuments(request: CreateBlockDocumentsCommand) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/Presence/CreateBlockDocuments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBlockDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBlockDocuments(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreateBlockDocuments(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    createBrandDocuments(request: CreateBrandDocumentsCommand) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/Presence/CreateBrandDocuments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBrandDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBrandDocuments(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreateBrandDocuments(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    createCompanyDocuments(request: CreateCompanyDocumentsCommand) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/Presence/CreateCompanyDocuments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCompanyDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCompanyDocuments(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCompanyDocuments(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    createSiteDocuments(request: CreateSiteDocumentsCommand) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/Presence/CreateSiteDocuments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSiteDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSiteDocuments(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSiteDocuments(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    createUnitDocuments(request: CreateUnitDocumentsCommand) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/Presence/CreateUnitDocuments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUnitDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUnitDocuments(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUnitDocuments(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    createZoneDocuments(request: CreateZoneDocumentsCommand) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/Presence/CreateZoneDocuments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateZoneDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateZoneDocuments(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreateZoneDocuments(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    removeAreaDocuments(request: RemoveAreaDocumentsCommand) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/Presence/RemoveAreaDocuments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveAreaDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveAreaDocuments(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveAreaDocuments(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    removeBlockDocuments(request: RemoveBlockDocumentsCommand) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/Presence/RemoveBlockDocuments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveBlockDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveBlockDocuments(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveBlockDocuments(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    removeBrandDocuments(request: RemoveBrandDocumentsCommand) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/Presence/RemoveBrandDocuments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveBrandDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveBrandDocuments(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveBrandDocuments(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    removeCompanyDocuments(request: RemoveCompanyDocumentsCommand) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/Presence/RemoveCompanyDocuments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveCompanyDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveCompanyDocuments(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveCompanyDocuments(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    removeSiteDocuments(request: RemoveSiteDocumentsCommand) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/Presence/RemoveSiteDocuments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveSiteDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveSiteDocuments(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveSiteDocuments(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    removeUnitDocuments(request: RemoveUnitDocumentsCommand) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/Presence/RemoveUnitDocuments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveUnitDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveUnitDocuments(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveUnitDocuments(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    removeZoneDocuments(request: RemoveZoneDocumentsCommand) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/Presence/RemoveZoneDocuments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveZoneDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveZoneDocuments(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveZoneDocuments(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }
}

export interface IPresenceGroupClient {
    createPresenceGroup(request: CreatePresenceGroupCommand): Observable<ApplicationResponse>;
    getPresenceGroups(searchText: string | null | undefined): Observable<ApplicationResponse>;
    getPresenceGroupById(id: number | undefined): Observable<ApplicationResponse>;
    editPresenceGroup(request: EditPresenceGroupCommand): Observable<ApplicationResponse>;
    removePresenceGroup(request: RemovePresenceGroupCommand): Observable<ApplicationResponse>;
    getPresenceGroupDocuments(request: GetPresenceGroupDocumentsQuery): Observable<ApplicationResponse>;
    addPresenceGroupDocument(presenceGroupId: number | undefined, documentTemplateId: number | undefined): Observable<ApplicationResponse>;
    removePresenceGroupDocument(request: RemovePresenceGroupDocumentCommand): Observable<ApplicationResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class PresenceGroupClient implements IPresenceGroupClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createPresenceGroup(request: CreatePresenceGroupCommand) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/PresenceGroup/CreatePresenceGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePresenceGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePresenceGroup(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePresenceGroup(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    getPresenceGroups(searchText: string | null | undefined) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/PresenceGroup/GetPresenceGroups?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPresenceGroups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPresenceGroups(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetPresenceGroups(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    getPresenceGroupById(id: number | undefined) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/PresenceGroup/GetPresenceGroupById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPresenceGroupById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPresenceGroupById(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetPresenceGroupById(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    editPresenceGroup(request: EditPresenceGroupCommand) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/PresenceGroup/EditPresenceGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditPresenceGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditPresenceGroup(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processEditPresenceGroup(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    removePresenceGroup(request: RemovePresenceGroupCommand) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/PresenceGroup/RemovePresenceGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovePresenceGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovePresenceGroup(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRemovePresenceGroup(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    getPresenceGroupDocuments(request: GetPresenceGroupDocumentsQuery) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/PresenceGroup/GetPresenceGroupDocuments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPresenceGroupDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPresenceGroupDocuments(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetPresenceGroupDocuments(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    addPresenceGroupDocument(presenceGroupId: number | undefined, documentTemplateId: number | undefined) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/PresenceGroup/AddPresenceGroupDocument?";
        if (presenceGroupId === null)
            throw new Error("The parameter 'presenceGroupId' cannot be null.");
        else if (presenceGroupId !== undefined)
            url_ += "PresenceGroupId=" + encodeURIComponent("" + presenceGroupId) + "&";
        if (documentTemplateId === null)
            throw new Error("The parameter 'documentTemplateId' cannot be null.");
        else if (documentTemplateId !== undefined)
            url_ += "DocumentTemplateId=" + encodeURIComponent("" + documentTemplateId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddPresenceGroupDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddPresenceGroupDocument(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAddPresenceGroupDocument(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    removePresenceGroupDocument(request: RemovePresenceGroupDocumentCommand) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/PresenceGroup/RemovePresenceGroupDocument";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovePresenceGroupDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovePresenceGroupDocument(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRemovePresenceGroupDocument(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }
}

export interface IFormClient {
    createForm(request: CreateFormCommand): Observable<ApplicationResponse>;
    getForms(request: GetFormsQuery | null | undefined): Observable<ApplicationResponseOfListOfBasicFormDto>;
    getFormById(id: number | undefined): Observable<ApplicationResponse>;
    editForm(request: EditFormCommand): Observable<ApplicationResponse>;
    deleteForm(request: RemoveFormCommand): Observable<ApplicationResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class FormClient implements IFormClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createForm(request: CreateFormCommand) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/Form/CreateForm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateForm(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreateForm(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    getForms(request: GetFormsQuery | null | undefined) : Observable<ApplicationResponseOfListOfBasicFormDto> {
        let url_ = this.baseUrl + "/api/Form/GetForms?";
        if (request !== undefined && request !== null)
            url_ += "request=" + encodeURIComponent("" + request) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForms(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponseOfListOfBasicFormDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponseOfListOfBasicFormDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetForms(response: HttpResponseBase): Observable<ApplicationResponseOfListOfBasicFormDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponseOfListOfBasicFormDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponseOfListOfBasicFormDto>(<any>null);
    }

    getFormById(id: number | undefined) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/Form/GetFormById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFormById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFormById(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetFormById(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    editForm(request: EditFormCommand) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/Form/EditForm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditForm(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processEditForm(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    deleteForm(request: RemoveFormCommand) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/Form/DeleteForm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteForm(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteForm(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }
}

export interface IDocumentTemplateClient {
    createDocumentTemplate(request: CreateDocumentTemplateCommand): Observable<ApplicationResponse>;
    getDocumentTemplates(searchText: string | null | undefined): Observable<ApplicationResponse>;
    getDocumentTemplateById(id: number | undefined): Observable<ApplicationResponse>;
    getDocumentTemplateTypes(request: GetDocumentTemplateTypesQuery | null | undefined): Observable<ApplicationResponse>;
    editDocumentTemplate(request: EditDocumentTemplateCommand): Observable<ApplicationResponse>;
    deleteDocumentTemplate(request: RemoveDocumentTemplateCommand): Observable<ApplicationResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class DocumentTemplateClient implements IDocumentTemplateClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createDocumentTemplate(request: CreateDocumentTemplateCommand) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/DocumentTemplate/CreateDocumentTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDocumentTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDocumentTemplate(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreateDocumentTemplate(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    getDocumentTemplates(searchText: string | null | undefined) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/DocumentTemplate/GetDocumentTemplates?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentTemplates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentTemplates(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocumentTemplates(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    getDocumentTemplateById(id: number | undefined) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/DocumentTemplate/GetDocumentTemplateById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentTemplateById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentTemplateById(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocumentTemplateById(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    getDocumentTemplateTypes(request: GetDocumentTemplateTypesQuery | null | undefined) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/DocumentTemplate/GetDocumentTemplateTypes?";
        if (request !== undefined && request !== null)
            url_ += "request=" + encodeURIComponent("" + request) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentTemplateTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentTemplateTypes(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocumentTemplateTypes(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    editDocumentTemplate(request: EditDocumentTemplateCommand) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/DocumentTemplate/EditDocumentTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditDocumentTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditDocumentTemplate(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processEditDocumentTemplate(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }

    deleteDocumentTemplate(request: RemoveDocumentTemplateCommand) : Observable<ApplicationResponse> {
        let url_ = this.baseUrl + "/api/DocumentTemplate/DeleteDocumentTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDocumentTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDocumentTemplate(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteDocumentTemplate(response: HttpResponseBase): Observable<ApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationResponse>(<any>null);
    }
}

export class GetSitesRequestDto implements IGetSitesRequestDto {
    searchText?: string | undefined;

    constructor(data?: IGetSitesRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchText = _data["searchText"];
        }
    }

    static fromJS(data: any): GetSitesRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSitesRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchText"] = this.searchText;
        return data; 
    }
}

export interface IGetSitesRequestDto {
    searchText?: string | undefined;
}

export class GetZonesRequestDto implements IGetZonesRequestDto {
    name?: string | undefined;

    constructor(data?: IGetZonesRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GetZonesRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetZonesRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface IGetZonesRequestDto {
    name?: string | undefined;
}

export class GetUnitsRequestDto implements IGetUnitsRequestDto {
    unitFilter?: { [key in keyof typeof UnitFilter]?: string; } | undefined;
    unitType?: number | undefined;
    unitTypeSub?: number | undefined;
    unitTypeCategory?: number | undefined;
    unitTypeCode?: number | undefined;
    representativeAreaId?: string | undefined;
    isActive?: boolean;
    siteId?: string | undefined;
    notIncludeZoneId?: string | undefined;
    notIncludeBlockId?: string | undefined;

    constructor(data?: IGetUnitsRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["unitFilter"]) {
                this.unitFilter = {} as any;
                for (let key in _data["unitFilter"]) {
                    if (_data["unitFilter"].hasOwnProperty(key))
                        (<any>this.unitFilter)![key] = _data["unitFilter"][key];
                }
            }
            this.unitType = _data["unitType"];
            this.unitTypeSub = _data["unitTypeSub"];
            this.unitTypeCategory = _data["unitTypeCategory"];
            this.unitTypeCode = _data["unitTypeCode"];
            this.representativeAreaId = _data["representativeAreaId"];
            this.isActive = _data["isActive"];
            this.siteId = _data["siteId"];
            this.notIncludeZoneId = _data["notIncludeZoneId"];
            this.notIncludeBlockId = _data["notIncludeBlockId"];
        }
    }

    static fromJS(data: any): GetUnitsRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetUnitsRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.unitFilter) {
            data["unitFilter"] = {};
            for (let key in this.unitFilter) {
                if (this.unitFilter.hasOwnProperty(key))
                    (<any>data["unitFilter"])[key] = this.unitFilter[key];
            }
        }
        data["unitType"] = this.unitType;
        data["unitTypeSub"] = this.unitTypeSub;
        data["unitTypeCategory"] = this.unitTypeCategory;
        data["unitTypeCode"] = this.unitTypeCode;
        data["representativeAreaId"] = this.representativeAreaId;
        data["isActive"] = this.isActive;
        data["siteId"] = this.siteId;
        data["notIncludeZoneId"] = this.notIncludeZoneId;
        data["notIncludeBlockId"] = this.notIncludeBlockId;
        return data; 
    }
}

export interface IGetUnitsRequestDto {
    unitFilter?: { [key in keyof typeof UnitFilter]?: string; } | undefined;
    unitType?: number | undefined;
    unitTypeSub?: number | undefined;
    unitTypeCategory?: number | undefined;
    unitTypeCode?: number | undefined;
    representativeAreaId?: string | undefined;
    isActive?: boolean;
    siteId?: string | undefined;
    notIncludeZoneId?: string | undefined;
    notIncludeBlockId?: string | undefined;
}

export enum UnitFilter {
    Zones = 2,
    Block = 3,
    Respresenter = 4,
    UnitNo = 7,
    DoorNumber = 9,
    UnitType = 10,
    UnitName = 11,
    UnitTypeSub = 12,
}

export class GetAreasRequestDto implements IGetAreasRequestDto {
    name?: string | undefined;
    isActive?: boolean | undefined;
    isRent?: boolean | undefined;
    areaTypeId?: (number | undefined)[] | undefined;
    siteId?: string | undefined;
    notIncludeZoneId?: string | undefined;
    notIncludeBlockId?: string | undefined;
    notIncludeUnitId?: number | undefined;
    notIncludeAreaId?: number | undefined;

    constructor(data?: IGetAreasRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            this.isRent = _data["isRent"];
            if (Array.isArray(_data["areaTypeId"])) {
                this.areaTypeId = [] as any;
                for (let item of _data["areaTypeId"])
                    this.areaTypeId!.push(item);
            }
            this.siteId = _data["siteId"];
            this.notIncludeZoneId = _data["notIncludeZoneId"];
            this.notIncludeBlockId = _data["notIncludeBlockId"];
            this.notIncludeUnitId = _data["notIncludeUnitId"];
            this.notIncludeAreaId = _data["notIncludeAreaId"];
        }
    }

    static fromJS(data: any): GetAreasRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAreasRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["isRent"] = this.isRent;
        if (Array.isArray(this.areaTypeId)) {
            data["areaTypeId"] = [];
            for (let item of this.areaTypeId)
                data["areaTypeId"].push(item);
        }
        data["siteId"] = this.siteId;
        data["notIncludeZoneId"] = this.notIncludeZoneId;
        data["notIncludeBlockId"] = this.notIncludeBlockId;
        data["notIncludeUnitId"] = this.notIncludeUnitId;
        data["notIncludeAreaId"] = this.notIncludeAreaId;
        return data; 
    }
}

export interface IGetAreasRequestDto {
    name?: string | undefined;
    isActive?: boolean | undefined;
    isRent?: boolean | undefined;
    areaTypeId?: (number | undefined)[] | undefined;
    siteId?: string | undefined;
    notIncludeZoneId?: string | undefined;
    notIncludeBlockId?: string | undefined;
    notIncludeUnitId?: number | undefined;
    notIncludeAreaId?: number | undefined;
}

export class GetCompaniesRequestDto implements IGetCompaniesRequestDto {
    companyFilter?: { [key in keyof typeof CompanyFilter]?: string; } | undefined;
    isFrontDeskAdded?: boolean | undefined;
    isActive?: boolean;

    constructor(data?: IGetCompaniesRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["companyFilter"]) {
                this.companyFilter = {} as any;
                for (let key in _data["companyFilter"]) {
                    if (_data["companyFilter"].hasOwnProperty(key))
                        (<any>this.companyFilter)![key] = _data["companyFilter"][key];
                }
            }
            this.isFrontDeskAdded = _data["isFrontDeskAdded"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): GetCompaniesRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCompaniesRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.companyFilter) {
            data["companyFilter"] = {};
            for (let key in this.companyFilter) {
                if (this.companyFilter.hasOwnProperty(key))
                    (<any>data["companyFilter"])[key] = this.companyFilter[key];
            }
        }
        data["isFrontDeskAdded"] = this.isFrontDeskAdded;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface IGetCompaniesRequestDto {
    companyFilter?: { [key in keyof typeof CompanyFilter]?: string; } | undefined;
    isFrontDeskAdded?: boolean | undefined;
    isActive?: boolean;
}

export enum CompanyFilter {
    CompanyName = 1,
    CompanyTaxNo = 2,
    CompanyResponsibleName = 3,
}

export class GetBrandsRequestDto implements IGetBrandsRequestDto {
    brandFilter?: { [key in keyof typeof BrandFilter]?: string; } | undefined;
    brandType?: (number | undefined)[] | undefined;
    companyName?: string | undefined;
    isFrontDeskAdded?: boolean | undefined;
    isActive?: boolean;

    constructor(data?: IGetBrandsRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["brandFilter"]) {
                this.brandFilter = {} as any;
                for (let key in _data["brandFilter"]) {
                    if (_data["brandFilter"].hasOwnProperty(key))
                        (<any>this.brandFilter)![key] = _data["brandFilter"][key];
                }
            }
            if (Array.isArray(_data["brandType"])) {
                this.brandType = [] as any;
                for (let item of _data["brandType"])
                    this.brandType!.push(item);
            }
            this.companyName = _data["companyName"];
            this.isFrontDeskAdded = _data["isFrontDeskAdded"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): GetBrandsRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBrandsRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.brandFilter) {
            data["brandFilter"] = {};
            for (let key in this.brandFilter) {
                if (this.brandFilter.hasOwnProperty(key))
                    (<any>data["brandFilter"])[key] = this.brandFilter[key];
            }
        }
        if (Array.isArray(this.brandType)) {
            data["brandType"] = [];
            for (let item of this.brandType)
                data["brandType"].push(item);
        }
        data["companyName"] = this.companyName;
        data["isFrontDeskAdded"] = this.isFrontDeskAdded;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface IGetBrandsRequestDto {
    brandFilter?: { [key in keyof typeof BrandFilter]?: string; } | undefined;
    brandType?: (number | undefined)[] | undefined;
    companyName?: string | undefined;
    isFrontDeskAdded?: boolean | undefined;
    isActive?: boolean;
}

export enum BrandFilter {
    BrandName = 1,
    BrandType = 2,
}

export class GetDepartmentsRequestDto implements IGetDepartmentsRequestDto {
    siteId?: string;
    isActive?: boolean;

    constructor(data?: IGetDepartmentsRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.siteId = _data["siteId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): GetDepartmentsRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDepartmentsRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["siteId"] = this.siteId;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface IGetDepartmentsRequestDto {
    siteId?: string;
    isActive?: boolean;
}

export class GetPersonnelsRequestDto implements IGetPersonnelsRequestDto {
    filterType?: EmployeeFilterType;
    searchString?: string | undefined;
    siteWorkUnitId?: number | undefined;
    siteWorkUnitIds?: (number | undefined)[] | undefined;
    employeeIdList?: number[] | undefined;

    constructor(data?: IGetPersonnelsRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filterType = _data["filterType"];
            this.searchString = _data["searchString"];
            this.siteWorkUnitId = _data["siteWorkUnitId"];
            if (Array.isArray(_data["siteWorkUnitIds"])) {
                this.siteWorkUnitIds = [] as any;
                for (let item of _data["siteWorkUnitIds"])
                    this.siteWorkUnitIds!.push(item);
            }
            if (Array.isArray(_data["employeeIdList"])) {
                this.employeeIdList = [] as any;
                for (let item of _data["employeeIdList"])
                    this.employeeIdList!.push(item);
            }
        }
    }

    static fromJS(data: any): GetPersonnelsRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPersonnelsRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filterType"] = this.filterType;
        data["searchString"] = this.searchString;
        data["siteWorkUnitId"] = this.siteWorkUnitId;
        if (Array.isArray(this.siteWorkUnitIds)) {
            data["siteWorkUnitIds"] = [];
            for (let item of this.siteWorkUnitIds)
                data["siteWorkUnitIds"].push(item);
        }
        if (Array.isArray(this.employeeIdList)) {
            data["employeeIdList"] = [];
            for (let item of this.employeeIdList)
                data["employeeIdList"].push(item);
        }
        return data; 
    }
}

export interface IGetPersonnelsRequestDto {
    filterType?: EmployeeFilterType;
    searchString?: string | undefined;
    siteWorkUnitId?: number | undefined;
    siteWorkUnitIds?: (number | undefined)[] | undefined;
    employeeIdList?: number[] | undefined;
}

export enum EmployeeFilterType {
    Active = 1,
    Passive = 2,
    All = 3,
}

export class SendOtpMessageResult implements ISendOtpMessageResult {
    result?: boolean;

    constructor(data?: ISendOtpMessageResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"];
        }
    }

    static fromJS(data: any): SendOtpMessageResult {
        data = typeof data === 'object' ? data : {};
        let result = new SendOtpMessageResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result;
        return data; 
    }
}

export interface ISendOtpMessageResult {
    result?: boolean;
}

export class ErrorResponseModel implements IErrorResponseModel {
    message?: string | undefined;

    constructor(data?: IErrorResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ErrorResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        return data; 
    }
}

export interface IErrorResponseModel {
    message?: string | undefined;
}

export class SendOtpToCustomerCommand implements ISendOtpToCustomerCommand {
    token?: string | undefined;
    customerId?: number;
    phoneNumber?: string | undefined;

    constructor(data?: ISendOtpToCustomerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.customerId = _data["customerId"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): SendOtpToCustomerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SendOtpToCustomerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["customerId"] = this.customerId;
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface ISendOtpToCustomerCommand {
    token?: string | undefined;
    customerId?: number;
    phoneNumber?: string | undefined;
}

export class ApplicationResponse implements IApplicationResponse {
    isError?: boolean;
    message?: string | undefined;
    result?: any | undefined;

    constructor(data?: IApplicationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            this.message = _data["message"];
            this.result = _data["result"];
        }
    }

    static fromJS(data: any): ApplicationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        data["message"] = this.message;
        data["result"] = this.result;
        return data; 
    }
}

export interface IApplicationResponse {
    isError?: boolean;
    message?: string | undefined;
    result?: any | undefined;
}

export class CreateVehicleTemplateCommand implements ICreateVehicleTemplateCommand {
    name?: LanguageString | undefined;
    isNeedDriver?: boolean;
    vehicleTemplateDocuments?: number[] | undefined;
    driverDocuments?: number[] | undefined;

    constructor(data?: ICreateVehicleTemplateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] ? LanguageString.fromJS(_data["name"]) : <any>undefined;
            this.isNeedDriver = _data["isNeedDriver"];
            if (Array.isArray(_data["vehicleTemplateDocuments"])) {
                this.vehicleTemplateDocuments = [] as any;
                for (let item of _data["vehicleTemplateDocuments"])
                    this.vehicleTemplateDocuments!.push(item);
            }
            if (Array.isArray(_data["driverDocuments"])) {
                this.driverDocuments = [] as any;
                for (let item of _data["driverDocuments"])
                    this.driverDocuments!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateVehicleTemplateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateVehicleTemplateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        data["isNeedDriver"] = this.isNeedDriver;
        if (Array.isArray(this.vehicleTemplateDocuments)) {
            data["vehicleTemplateDocuments"] = [];
            for (let item of this.vehicleTemplateDocuments)
                data["vehicleTemplateDocuments"].push(item);
        }
        if (Array.isArray(this.driverDocuments)) {
            data["driverDocuments"] = [];
            for (let item of this.driverDocuments)
                data["driverDocuments"].push(item);
        }
        return data; 
    }
}

export interface ICreateVehicleTemplateCommand {
    name?: LanguageString | undefined;
    isNeedDriver?: boolean;
    vehicleTemplateDocuments?: number[] | undefined;
    driverDocuments?: number[] | undefined;
}

export class LanguageString implements ILanguageString {

    [key: string]: string | any; 

    constructor(data?: ILanguageString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): LanguageString {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data; 
    }
}

export interface ILanguageString {

    [key: string]: string | any; 
}

export enum LanguageCode {
    Tr = 1,
    En = 2,
}

export class GetVehicleTemplateQuery implements IGetVehicleTemplateQuery {

    constructor(data?: IGetVehicleTemplateQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetVehicleTemplateQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetVehicleTemplateQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IGetVehicleTemplateQuery {
}

export class EditVehicleTemplateCommand extends CreateVehicleTemplateCommand implements IEditVehicleTemplateCommand {
    id?: number;

    constructor(data?: IEditVehicleTemplateCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EditVehicleTemplateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditVehicleTemplateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data; 
    }
}

export interface IEditVehicleTemplateCommand extends ICreateVehicleTemplateCommand {
    id?: number;
}

export class RemoveVehicleTemplateCommand implements IRemoveVehicleTemplateCommand {
    id?: number;

    constructor(data?: IRemoveVehicleTemplateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RemoveVehicleTemplateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveVehicleTemplateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IRemoveVehicleTemplateCommand {
    id?: number;
}

export class CreateUserGroupCommand implements ICreateUserGroupCommand {
    name?: LanguageString | undefined;
    personnelIds?: number[] | undefined;

    constructor(data?: ICreateUserGroupCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] ? LanguageString.fromJS(_data["name"]) : <any>undefined;
            if (Array.isArray(_data["personnelIds"])) {
                this.personnelIds = [] as any;
                for (let item of _data["personnelIds"])
                    this.personnelIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateUserGroupCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserGroupCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        if (Array.isArray(this.personnelIds)) {
            data["personnelIds"] = [];
            for (let item of this.personnelIds)
                data["personnelIds"].push(item);
        }
        return data; 
    }
}

export interface ICreateUserGroupCommand {
    name?: LanguageString | undefined;
    personnelIds?: number[] | undefined;
}

export class EditUserGroupCommand extends CreateUserGroupCommand implements IEditUserGroupCommand {
    id?: number;

    constructor(data?: IEditUserGroupCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EditUserGroupCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditUserGroupCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data; 
    }
}

export interface IEditUserGroupCommand extends ICreateUserGroupCommand {
    id?: number;
}

export class RemoveUserGroupCommand implements IRemoveUserGroupCommand {
    id?: number;

    constructor(data?: IRemoveUserGroupCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RemoveUserGroupCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveUserGroupCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IRemoveUserGroupCommand {
    id?: number;
}

export class CreateServiceCategoryCommand implements ICreateServiceCategoryCommand {
    name?: LanguageString | undefined;
    description?: LanguageString | undefined;
    isMainCategory?: boolean;
    serviceCategoryDetails?: CreateServiceCategoryDetailsDto | undefined;

    constructor(data?: ICreateServiceCategoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] ? LanguageString.fromJS(_data["name"]) : <any>undefined;
            this.description = _data["description"] ? LanguageString.fromJS(_data["description"]) : <any>undefined;
            this.isMainCategory = _data["isMainCategory"];
            this.serviceCategoryDetails = _data["serviceCategoryDetails"] ? CreateServiceCategoryDetailsDto.fromJS(_data["serviceCategoryDetails"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateServiceCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateServiceCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        data["description"] = this.description ? this.description.toJSON() : <any>undefined;
        data["isMainCategory"] = this.isMainCategory;
        data["serviceCategoryDetails"] = this.serviceCategoryDetails ? this.serviceCategoryDetails.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateServiceCategoryCommand {
    name?: LanguageString | undefined;
    description?: LanguageString | undefined;
    isMainCategory?: boolean;
    serviceCategoryDetails?: CreateServiceCategoryDetailsDto | undefined;
}

export class CreateServiceCategoryDetailsDto implements ICreateServiceCategoryDetailsDto {
    maxServiceDuration?: number;
    serviceDurationUnit?: TimeUnit;
    minOrderDuration?: number;
    minOrderDurationUnit?: TimeUnit;
    maxOrderDuration?: number;
    maxOrderDurationUnit?: TimeUnit;
    maxPersonnelCount?: number;
    personnelDocuments?: number[] | undefined;
    parentServiceCategoryId?: number | undefined;
    isParallelApprovement?: boolean;
    serviceCategoryRoles?: CreateCategoryRoleDto[] | undefined;
    documents?: number[] | undefined;
    vehicleTemplates?: CreateVehicleTemplateCategoryDto[] | undefined;
    serviceCategoryAreas?: number[] | undefined;
    serviceCategoryBlocks?: string[] | undefined;
    serviceCategoryBrands?: number[] | undefined;
    serviceCategoryCompanies?: number[] | undefined;
    serviceCategorySites?: string[] | undefined;
    serviceCategoryUnits?: number[] | undefined;
    serviceCategoryZones?: string[] | undefined;
    serviceCategoryPresenceGroups?: number[] | undefined;

    constructor(data?: ICreateServiceCategoryDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxServiceDuration = _data["maxServiceDuration"];
            this.serviceDurationUnit = _data["serviceDurationUnit"];
            this.minOrderDuration = _data["minOrderDuration"];
            this.minOrderDurationUnit = _data["minOrderDurationUnit"];
            this.maxOrderDuration = _data["maxOrderDuration"];
            this.maxOrderDurationUnit = _data["maxOrderDurationUnit"];
            this.maxPersonnelCount = _data["maxPersonnelCount"];
            if (Array.isArray(_data["personnelDocuments"])) {
                this.personnelDocuments = [] as any;
                for (let item of _data["personnelDocuments"])
                    this.personnelDocuments!.push(item);
            }
            this.parentServiceCategoryId = _data["parentServiceCategoryId"];
            this.isParallelApprovement = _data["isParallelApprovement"];
            if (Array.isArray(_data["serviceCategoryRoles"])) {
                this.serviceCategoryRoles = [] as any;
                for (let item of _data["serviceCategoryRoles"])
                    this.serviceCategoryRoles!.push(CreateCategoryRoleDto.fromJS(item));
            }
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(item);
            }
            if (Array.isArray(_data["vehicleTemplates"])) {
                this.vehicleTemplates = [] as any;
                for (let item of _data["vehicleTemplates"])
                    this.vehicleTemplates!.push(CreateVehicleTemplateCategoryDto.fromJS(item));
            }
            if (Array.isArray(_data["serviceCategoryAreas"])) {
                this.serviceCategoryAreas = [] as any;
                for (let item of _data["serviceCategoryAreas"])
                    this.serviceCategoryAreas!.push(item);
            }
            if (Array.isArray(_data["serviceCategoryBlocks"])) {
                this.serviceCategoryBlocks = [] as any;
                for (let item of _data["serviceCategoryBlocks"])
                    this.serviceCategoryBlocks!.push(item);
            }
            if (Array.isArray(_data["serviceCategoryBrands"])) {
                this.serviceCategoryBrands = [] as any;
                for (let item of _data["serviceCategoryBrands"])
                    this.serviceCategoryBrands!.push(item);
            }
            if (Array.isArray(_data["serviceCategoryCompanies"])) {
                this.serviceCategoryCompanies = [] as any;
                for (let item of _data["serviceCategoryCompanies"])
                    this.serviceCategoryCompanies!.push(item);
            }
            if (Array.isArray(_data["serviceCategorySites"])) {
                this.serviceCategorySites = [] as any;
                for (let item of _data["serviceCategorySites"])
                    this.serviceCategorySites!.push(item);
            }
            if (Array.isArray(_data["serviceCategoryUnits"])) {
                this.serviceCategoryUnits = [] as any;
                for (let item of _data["serviceCategoryUnits"])
                    this.serviceCategoryUnits!.push(item);
            }
            if (Array.isArray(_data["serviceCategoryZones"])) {
                this.serviceCategoryZones = [] as any;
                for (let item of _data["serviceCategoryZones"])
                    this.serviceCategoryZones!.push(item);
            }
            if (Array.isArray(_data["serviceCategoryPresenceGroups"])) {
                this.serviceCategoryPresenceGroups = [] as any;
                for (let item of _data["serviceCategoryPresenceGroups"])
                    this.serviceCategoryPresenceGroups!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateServiceCategoryDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateServiceCategoryDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxServiceDuration"] = this.maxServiceDuration;
        data["serviceDurationUnit"] = this.serviceDurationUnit;
        data["minOrderDuration"] = this.minOrderDuration;
        data["minOrderDurationUnit"] = this.minOrderDurationUnit;
        data["maxOrderDuration"] = this.maxOrderDuration;
        data["maxOrderDurationUnit"] = this.maxOrderDurationUnit;
        data["maxPersonnelCount"] = this.maxPersonnelCount;
        if (Array.isArray(this.personnelDocuments)) {
            data["personnelDocuments"] = [];
            for (let item of this.personnelDocuments)
                data["personnelDocuments"].push(item);
        }
        data["parentServiceCategoryId"] = this.parentServiceCategoryId;
        data["isParallelApprovement"] = this.isParallelApprovement;
        if (Array.isArray(this.serviceCategoryRoles)) {
            data["serviceCategoryRoles"] = [];
            for (let item of this.serviceCategoryRoles)
                data["serviceCategoryRoles"].push(item.toJSON());
        }
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item);
        }
        if (Array.isArray(this.vehicleTemplates)) {
            data["vehicleTemplates"] = [];
            for (let item of this.vehicleTemplates)
                data["vehicleTemplates"].push(item.toJSON());
        }
        if (Array.isArray(this.serviceCategoryAreas)) {
            data["serviceCategoryAreas"] = [];
            for (let item of this.serviceCategoryAreas)
                data["serviceCategoryAreas"].push(item);
        }
        if (Array.isArray(this.serviceCategoryBlocks)) {
            data["serviceCategoryBlocks"] = [];
            for (let item of this.serviceCategoryBlocks)
                data["serviceCategoryBlocks"].push(item);
        }
        if (Array.isArray(this.serviceCategoryBrands)) {
            data["serviceCategoryBrands"] = [];
            for (let item of this.serviceCategoryBrands)
                data["serviceCategoryBrands"].push(item);
        }
        if (Array.isArray(this.serviceCategoryCompanies)) {
            data["serviceCategoryCompanies"] = [];
            for (let item of this.serviceCategoryCompanies)
                data["serviceCategoryCompanies"].push(item);
        }
        if (Array.isArray(this.serviceCategorySites)) {
            data["serviceCategorySites"] = [];
            for (let item of this.serviceCategorySites)
                data["serviceCategorySites"].push(item);
        }
        if (Array.isArray(this.serviceCategoryUnits)) {
            data["serviceCategoryUnits"] = [];
            for (let item of this.serviceCategoryUnits)
                data["serviceCategoryUnits"].push(item);
        }
        if (Array.isArray(this.serviceCategoryZones)) {
            data["serviceCategoryZones"] = [];
            for (let item of this.serviceCategoryZones)
                data["serviceCategoryZones"].push(item);
        }
        if (Array.isArray(this.serviceCategoryPresenceGroups)) {
            data["serviceCategoryPresenceGroups"] = [];
            for (let item of this.serviceCategoryPresenceGroups)
                data["serviceCategoryPresenceGroups"].push(item);
        }
        return data; 
    }
}

export interface ICreateServiceCategoryDetailsDto {
    maxServiceDuration?: number;
    serviceDurationUnit?: TimeUnit;
    minOrderDuration?: number;
    minOrderDurationUnit?: TimeUnit;
    maxOrderDuration?: number;
    maxOrderDurationUnit?: TimeUnit;
    maxPersonnelCount?: number;
    personnelDocuments?: number[] | undefined;
    parentServiceCategoryId?: number | undefined;
    isParallelApprovement?: boolean;
    serviceCategoryRoles?: CreateCategoryRoleDto[] | undefined;
    documents?: number[] | undefined;
    vehicleTemplates?: CreateVehicleTemplateCategoryDto[] | undefined;
    serviceCategoryAreas?: number[] | undefined;
    serviceCategoryBlocks?: string[] | undefined;
    serviceCategoryBrands?: number[] | undefined;
    serviceCategoryCompanies?: number[] | undefined;
    serviceCategorySites?: string[] | undefined;
    serviceCategoryUnits?: number[] | undefined;
    serviceCategoryZones?: string[] | undefined;
    serviceCategoryPresenceGroups?: number[] | undefined;
}

export enum TimeUnit {
    Hours = 0,
    Days = 1,
    Weeks = 2,
    Months = 3,
    Years = 4,
}

export class CreateCategoryRoleDto implements ICreateCategoryRoleDto {
    role?: Role;
    responsibleDepartments?: number[] | undefined;
    responsiblePersonnels?: number[] | undefined;
    responsibleUserGroups?: number[] | undefined;

    constructor(data?: ICreateCategoryRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"];
            if (Array.isArray(_data["responsibleDepartments"])) {
                this.responsibleDepartments = [] as any;
                for (let item of _data["responsibleDepartments"])
                    this.responsibleDepartments!.push(item);
            }
            if (Array.isArray(_data["responsiblePersonnels"])) {
                this.responsiblePersonnels = [] as any;
                for (let item of _data["responsiblePersonnels"])
                    this.responsiblePersonnels!.push(item);
            }
            if (Array.isArray(_data["responsibleUserGroups"])) {
                this.responsibleUserGroups = [] as any;
                for (let item of _data["responsibleUserGroups"])
                    this.responsibleUserGroups!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateCategoryRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role;
        if (Array.isArray(this.responsibleDepartments)) {
            data["responsibleDepartments"] = [];
            for (let item of this.responsibleDepartments)
                data["responsibleDepartments"].push(item);
        }
        if (Array.isArray(this.responsiblePersonnels)) {
            data["responsiblePersonnels"] = [];
            for (let item of this.responsiblePersonnels)
                data["responsiblePersonnels"].push(item);
        }
        if (Array.isArray(this.responsibleUserGroups)) {
            data["responsibleUserGroups"] = [];
            for (let item of this.responsibleUserGroups)
                data["responsibleUserGroups"].push(item);
        }
        return data; 
    }
}

export interface ICreateCategoryRoleDto {
    role?: Role;
    responsibleDepartments?: number[] | undefined;
    responsiblePersonnels?: number[] | undefined;
    responsibleUserGroups?: number[] | undefined;
}

export enum Role {
    Approver = 0,
    Observer = 1,
    Reporter = 2,
    Canceler = 3,
}

export class CreateVehicleTemplateCategoryDto implements ICreateVehicleTemplateCategoryDto {
    vehicleTemplateId?: number;
    vehicleTemplateDocuments?: CreateCategoryVehicleTemplateDocuments[] | undefined;

    constructor(data?: ICreateVehicleTemplateCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vehicleTemplateId = _data["vehicleTemplateId"];
            if (Array.isArray(_data["vehicleTemplateDocuments"])) {
                this.vehicleTemplateDocuments = [] as any;
                for (let item of _data["vehicleTemplateDocuments"])
                    this.vehicleTemplateDocuments!.push(CreateCategoryVehicleTemplateDocuments.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateVehicleTemplateCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateVehicleTemplateCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehicleTemplateId"] = this.vehicleTemplateId;
        if (Array.isArray(this.vehicleTemplateDocuments)) {
            data["vehicleTemplateDocuments"] = [];
            for (let item of this.vehicleTemplateDocuments)
                data["vehicleTemplateDocuments"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateVehicleTemplateCategoryDto {
    vehicleTemplateId?: number;
    vehicleTemplateDocuments?: CreateCategoryVehicleTemplateDocuments[] | undefined;
}

export class CreateCategoryVehicleTemplateDocuments implements ICreateCategoryVehicleTemplateDocuments {
    documentTemplateId?: number;
    isRequired?: boolean;
    vehicleDocumentType?: VehicleDocumentType;

    constructor(data?: ICreateCategoryVehicleTemplateDocuments) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentTemplateId = _data["documentTemplateId"];
            this.isRequired = _data["isRequired"];
            this.vehicleDocumentType = _data["vehicleDocumentType"];
        }
    }

    static fromJS(data: any): CreateCategoryVehicleTemplateDocuments {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryVehicleTemplateDocuments();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentTemplateId"] = this.documentTemplateId;
        data["isRequired"] = this.isRequired;
        data["vehicleDocumentType"] = this.vehicleDocumentType;
        return data; 
    }
}

export interface ICreateCategoryVehicleTemplateDocuments {
    documentTemplateId?: number;
    isRequired?: boolean;
    vehicleDocumentType?: VehicleDocumentType;
}

export enum VehicleDocumentType {
    Vehicle = 0,
    Driver = 1,
}

export class EditServiceCategoryCommand extends CreateServiceCategoryCommand implements IEditServiceCategoryCommand {
    id?: number;

    constructor(data?: IEditServiceCategoryCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EditServiceCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditServiceCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data; 
    }
}

export interface IEditServiceCategoryCommand extends ICreateServiceCategoryCommand {
    id?: number;
}

export class RemoveServiceCategoryCommand implements IRemoveServiceCategoryCommand {
    id?: number;

    constructor(data?: IRemoveServiceCategoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RemoveServiceCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveServiceCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IRemoveServiceCategoryCommand {
    id?: number;
}

export class GetAreaDocumentsQuery implements IGetAreaDocumentsQuery {
    areaId?: number;

    constructor(data?: IGetAreaDocumentsQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.areaId = _data["areaId"];
        }
    }

    static fromJS(data: any): GetAreaDocumentsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetAreaDocumentsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["areaId"] = this.areaId;
        return data; 
    }
}

export interface IGetAreaDocumentsQuery {
    areaId?: number;
}

export class GetBlockDocumentsQuery implements IGetBlockDocumentsQuery {
    blockId?: string;

    constructor(data?: IGetBlockDocumentsQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.blockId = _data["blockId"];
        }
    }

    static fromJS(data: any): GetBlockDocumentsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetBlockDocumentsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["blockId"] = this.blockId;
        return data; 
    }
}

export interface IGetBlockDocumentsQuery {
    blockId?: string;
}

export class GetBrandDocumentsQuery implements IGetBrandDocumentsQuery {
    brandId?: number;

    constructor(data?: IGetBrandDocumentsQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.brandId = _data["brandId"];
        }
    }

    static fromJS(data: any): GetBrandDocumentsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetBrandDocumentsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brandId"] = this.brandId;
        return data; 
    }
}

export interface IGetBrandDocumentsQuery {
    brandId?: number;
}

export class GetCompanyDocumentsQuery implements IGetCompanyDocumentsQuery {
    companyId?: number;

    constructor(data?: IGetCompanyDocumentsQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyId = _data["companyId"];
        }
    }

    static fromJS(data: any): GetCompanyDocumentsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetCompanyDocumentsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyId"] = this.companyId;
        return data; 
    }
}

export interface IGetCompanyDocumentsQuery {
    companyId?: number;
}

export class GetSiteDocumentsQuery implements IGetSiteDocumentsQuery {
    siteId?: string;

    constructor(data?: IGetSiteDocumentsQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.siteId = _data["siteId"];
        }
    }

    static fromJS(data: any): GetSiteDocumentsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetSiteDocumentsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["siteId"] = this.siteId;
        return data; 
    }
}

export interface IGetSiteDocumentsQuery {
    siteId?: string;
}

export class GetUnitDocumentsQuery implements IGetUnitDocumentsQuery {
    unitId?: number;

    constructor(data?: IGetUnitDocumentsQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.unitId = _data["unitId"];
        }
    }

    static fromJS(data: any): GetUnitDocumentsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetUnitDocumentsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unitId"] = this.unitId;
        return data; 
    }
}

export interface IGetUnitDocumentsQuery {
    unitId?: number;
}

export class GetZoneDocumentsQuery implements IGetZoneDocumentsQuery {
    zoneId?: string;

    constructor(data?: IGetZoneDocumentsQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.zoneId = _data["zoneId"];
        }
    }

    static fromJS(data: any): GetZoneDocumentsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetZoneDocumentsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["zoneId"] = this.zoneId;
        return data; 
    }
}

export interface IGetZoneDocumentsQuery {
    zoneId?: string;
}

export class CreateAreaDocumentsCommand implements ICreateAreaDocumentsCommand {
    areaId?: number;
    documentTemplateId?: number;

    constructor(data?: ICreateAreaDocumentsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.areaId = _data["areaId"];
            this.documentTemplateId = _data["documentTemplateId"];
        }
    }

    static fromJS(data: any): CreateAreaDocumentsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAreaDocumentsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["areaId"] = this.areaId;
        data["documentTemplateId"] = this.documentTemplateId;
        return data; 
    }
}

export interface ICreateAreaDocumentsCommand {
    areaId?: number;
    documentTemplateId?: number;
}

export class CreateBlockDocumentsCommand implements ICreateBlockDocumentsCommand {
    blockId?: string;
    documentTemplateId?: number;

    constructor(data?: ICreateBlockDocumentsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.blockId = _data["blockId"];
            this.documentTemplateId = _data["documentTemplateId"];
        }
    }

    static fromJS(data: any): CreateBlockDocumentsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBlockDocumentsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["blockId"] = this.blockId;
        data["documentTemplateId"] = this.documentTemplateId;
        return data; 
    }
}

export interface ICreateBlockDocumentsCommand {
    blockId?: string;
    documentTemplateId?: number;
}

export class CreateBrandDocumentsCommand implements ICreateBrandDocumentsCommand {
    brandId?: number;
    documentTemplateId?: number;

    constructor(data?: ICreateBrandDocumentsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.brandId = _data["brandId"];
            this.documentTemplateId = _data["documentTemplateId"];
        }
    }

    static fromJS(data: any): CreateBrandDocumentsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBrandDocumentsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brandId"] = this.brandId;
        data["documentTemplateId"] = this.documentTemplateId;
        return data; 
    }
}

export interface ICreateBrandDocumentsCommand {
    brandId?: number;
    documentTemplateId?: number;
}

export class CreateCompanyDocumentsCommand implements ICreateCompanyDocumentsCommand {
    companyId?: number;
    documentTemplateId?: number;

    constructor(data?: ICreateCompanyDocumentsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyId = _data["companyId"];
            this.documentTemplateId = _data["documentTemplateId"];
        }
    }

    static fromJS(data: any): CreateCompanyDocumentsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCompanyDocumentsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyId"] = this.companyId;
        data["documentTemplateId"] = this.documentTemplateId;
        return data; 
    }
}

export interface ICreateCompanyDocumentsCommand {
    companyId?: number;
    documentTemplateId?: number;
}

export class CreateSiteDocumentsCommand implements ICreateSiteDocumentsCommand {
    siteId?: string;
    documentTemplateId?: number;

    constructor(data?: ICreateSiteDocumentsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.siteId = _data["siteId"];
            this.documentTemplateId = _data["documentTemplateId"];
        }
    }

    static fromJS(data: any): CreateSiteDocumentsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSiteDocumentsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["siteId"] = this.siteId;
        data["documentTemplateId"] = this.documentTemplateId;
        return data; 
    }
}

export interface ICreateSiteDocumentsCommand {
    siteId?: string;
    documentTemplateId?: number;
}

export class CreateUnitDocumentsCommand implements ICreateUnitDocumentsCommand {
    unitId?: number;
    documentTemplateId?: number;

    constructor(data?: ICreateUnitDocumentsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.unitId = _data["unitId"];
            this.documentTemplateId = _data["documentTemplateId"];
        }
    }

    static fromJS(data: any): CreateUnitDocumentsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUnitDocumentsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unitId"] = this.unitId;
        data["documentTemplateId"] = this.documentTemplateId;
        return data; 
    }
}

export interface ICreateUnitDocumentsCommand {
    unitId?: number;
    documentTemplateId?: number;
}

export class CreateZoneDocumentsCommand implements ICreateZoneDocumentsCommand {
    zoneId?: string;
    documentTemplateId?: number;

    constructor(data?: ICreateZoneDocumentsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.zoneId = _data["zoneId"];
            this.documentTemplateId = _data["documentTemplateId"];
        }
    }

    static fromJS(data: any): CreateZoneDocumentsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateZoneDocumentsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["zoneId"] = this.zoneId;
        data["documentTemplateId"] = this.documentTemplateId;
        return data; 
    }
}

export interface ICreateZoneDocumentsCommand {
    zoneId?: string;
    documentTemplateId?: number;
}

export class RemoveAreaDocumentsCommand implements IRemoveAreaDocumentsCommand {
    areaId?: number;
    documentTemplateId?: number;

    constructor(data?: IRemoveAreaDocumentsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.areaId = _data["areaId"];
            this.documentTemplateId = _data["documentTemplateId"];
        }
    }

    static fromJS(data: any): RemoveAreaDocumentsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveAreaDocumentsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["areaId"] = this.areaId;
        data["documentTemplateId"] = this.documentTemplateId;
        return data; 
    }
}

export interface IRemoveAreaDocumentsCommand {
    areaId?: number;
    documentTemplateId?: number;
}

export class RemoveBlockDocumentsCommand implements IRemoveBlockDocumentsCommand {
    blockId?: string;
    documentTemplateId?: number;

    constructor(data?: IRemoveBlockDocumentsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.blockId = _data["blockId"];
            this.documentTemplateId = _data["documentTemplateId"];
        }
    }

    static fromJS(data: any): RemoveBlockDocumentsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveBlockDocumentsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["blockId"] = this.blockId;
        data["documentTemplateId"] = this.documentTemplateId;
        return data; 
    }
}

export interface IRemoveBlockDocumentsCommand {
    blockId?: string;
    documentTemplateId?: number;
}

export class RemoveBrandDocumentsCommand implements IRemoveBrandDocumentsCommand {
    brandId?: number;
    documentTemplateId?: number;

    constructor(data?: IRemoveBrandDocumentsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.brandId = _data["brandId"];
            this.documentTemplateId = _data["documentTemplateId"];
        }
    }

    static fromJS(data: any): RemoveBrandDocumentsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveBrandDocumentsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brandId"] = this.brandId;
        data["documentTemplateId"] = this.documentTemplateId;
        return data; 
    }
}

export interface IRemoveBrandDocumentsCommand {
    brandId?: number;
    documentTemplateId?: number;
}

export class RemoveCompanyDocumentsCommand implements IRemoveCompanyDocumentsCommand {
    companyId?: number;
    documentTemplateId?: number;

    constructor(data?: IRemoveCompanyDocumentsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyId = _data["companyId"];
            this.documentTemplateId = _data["documentTemplateId"];
        }
    }

    static fromJS(data: any): RemoveCompanyDocumentsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveCompanyDocumentsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyId"] = this.companyId;
        data["documentTemplateId"] = this.documentTemplateId;
        return data; 
    }
}

export interface IRemoveCompanyDocumentsCommand {
    companyId?: number;
    documentTemplateId?: number;
}

export class RemoveSiteDocumentsCommand implements IRemoveSiteDocumentsCommand {
    siteId?: string;
    documentTemplateId?: number;

    constructor(data?: IRemoveSiteDocumentsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.siteId = _data["siteId"];
            this.documentTemplateId = _data["documentTemplateId"];
        }
    }

    static fromJS(data: any): RemoveSiteDocumentsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveSiteDocumentsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["siteId"] = this.siteId;
        data["documentTemplateId"] = this.documentTemplateId;
        return data; 
    }
}

export interface IRemoveSiteDocumentsCommand {
    siteId?: string;
    documentTemplateId?: number;
}

export class RemoveUnitDocumentsCommand implements IRemoveUnitDocumentsCommand {
    unitId?: number;
    documentTemplateId?: number;

    constructor(data?: IRemoveUnitDocumentsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.unitId = _data["unitId"];
            this.documentTemplateId = _data["documentTemplateId"];
        }
    }

    static fromJS(data: any): RemoveUnitDocumentsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveUnitDocumentsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unitId"] = this.unitId;
        data["documentTemplateId"] = this.documentTemplateId;
        return data; 
    }
}

export interface IRemoveUnitDocumentsCommand {
    unitId?: number;
    documentTemplateId?: number;
}

export class RemoveZoneDocumentsCommand implements IRemoveZoneDocumentsCommand {
    zoneId?: string;
    documentTemplateId?: number;

    constructor(data?: IRemoveZoneDocumentsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.zoneId = _data["zoneId"];
            this.documentTemplateId = _data["documentTemplateId"];
        }
    }

    static fromJS(data: any): RemoveZoneDocumentsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveZoneDocumentsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["zoneId"] = this.zoneId;
        data["documentTemplateId"] = this.documentTemplateId;
        return data; 
    }
}

export interface IRemoveZoneDocumentsCommand {
    zoneId?: string;
    documentTemplateId?: number;
}

export class CreatePresenceGroupCommand implements ICreatePresenceGroupCommand {
    name?: LanguageString | undefined;
    presenceGroupAreas?: number[] | undefined;
    presenceGroupBlocks?: string[] | undefined;
    presenceGroupCompanies?: number[] | undefined;
    presenceGroupBrands?: number[] | undefined;
    presenceGroupSites?: string[] | undefined;
    presenceGroupUnits?: number[] | undefined;
    presenceGroupZones?: string[] | undefined;

    constructor(data?: ICreatePresenceGroupCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] ? LanguageString.fromJS(_data["name"]) : <any>undefined;
            if (Array.isArray(_data["presenceGroupAreas"])) {
                this.presenceGroupAreas = [] as any;
                for (let item of _data["presenceGroupAreas"])
                    this.presenceGroupAreas!.push(item);
            }
            if (Array.isArray(_data["presenceGroupBlocks"])) {
                this.presenceGroupBlocks = [] as any;
                for (let item of _data["presenceGroupBlocks"])
                    this.presenceGroupBlocks!.push(item);
            }
            if (Array.isArray(_data["presenceGroupCompanies"])) {
                this.presenceGroupCompanies = [] as any;
                for (let item of _data["presenceGroupCompanies"])
                    this.presenceGroupCompanies!.push(item);
            }
            if (Array.isArray(_data["presenceGroupBrands"])) {
                this.presenceGroupBrands = [] as any;
                for (let item of _data["presenceGroupBrands"])
                    this.presenceGroupBrands!.push(item);
            }
            if (Array.isArray(_data["presenceGroupSites"])) {
                this.presenceGroupSites = [] as any;
                for (let item of _data["presenceGroupSites"])
                    this.presenceGroupSites!.push(item);
            }
            if (Array.isArray(_data["presenceGroupUnits"])) {
                this.presenceGroupUnits = [] as any;
                for (let item of _data["presenceGroupUnits"])
                    this.presenceGroupUnits!.push(item);
            }
            if (Array.isArray(_data["presenceGroupZones"])) {
                this.presenceGroupZones = [] as any;
                for (let item of _data["presenceGroupZones"])
                    this.presenceGroupZones!.push(item);
            }
        }
    }

    static fromJS(data: any): CreatePresenceGroupCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePresenceGroupCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        if (Array.isArray(this.presenceGroupAreas)) {
            data["presenceGroupAreas"] = [];
            for (let item of this.presenceGroupAreas)
                data["presenceGroupAreas"].push(item);
        }
        if (Array.isArray(this.presenceGroupBlocks)) {
            data["presenceGroupBlocks"] = [];
            for (let item of this.presenceGroupBlocks)
                data["presenceGroupBlocks"].push(item);
        }
        if (Array.isArray(this.presenceGroupCompanies)) {
            data["presenceGroupCompanies"] = [];
            for (let item of this.presenceGroupCompanies)
                data["presenceGroupCompanies"].push(item);
        }
        if (Array.isArray(this.presenceGroupBrands)) {
            data["presenceGroupBrands"] = [];
            for (let item of this.presenceGroupBrands)
                data["presenceGroupBrands"].push(item);
        }
        if (Array.isArray(this.presenceGroupSites)) {
            data["presenceGroupSites"] = [];
            for (let item of this.presenceGroupSites)
                data["presenceGroupSites"].push(item);
        }
        if (Array.isArray(this.presenceGroupUnits)) {
            data["presenceGroupUnits"] = [];
            for (let item of this.presenceGroupUnits)
                data["presenceGroupUnits"].push(item);
        }
        if (Array.isArray(this.presenceGroupZones)) {
            data["presenceGroupZones"] = [];
            for (let item of this.presenceGroupZones)
                data["presenceGroupZones"].push(item);
        }
        return data; 
    }
}

export interface ICreatePresenceGroupCommand {
    name?: LanguageString | undefined;
    presenceGroupAreas?: number[] | undefined;
    presenceGroupBlocks?: string[] | undefined;
    presenceGroupCompanies?: number[] | undefined;
    presenceGroupBrands?: number[] | undefined;
    presenceGroupSites?: string[] | undefined;
    presenceGroupUnits?: number[] | undefined;
    presenceGroupZones?: string[] | undefined;
}

export class EditPresenceGroupCommand extends CreatePresenceGroupCommand implements IEditPresenceGroupCommand {
    id?: number;

    constructor(data?: IEditPresenceGroupCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EditPresenceGroupCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditPresenceGroupCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data; 
    }
}

export interface IEditPresenceGroupCommand extends ICreatePresenceGroupCommand {
    id?: number;
}

export class RemovePresenceGroupCommand implements IRemovePresenceGroupCommand {
    id?: number;

    constructor(data?: IRemovePresenceGroupCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RemovePresenceGroupCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RemovePresenceGroupCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IRemovePresenceGroupCommand {
    id?: number;
}

export class GetPresenceGroupDocumentsQuery implements IGetPresenceGroupDocumentsQuery {
    presenceGroupId?: number;

    constructor(data?: IGetPresenceGroupDocumentsQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.presenceGroupId = _data["presenceGroupId"];
        }
    }

    static fromJS(data: any): GetPresenceGroupDocumentsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetPresenceGroupDocumentsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["presenceGroupId"] = this.presenceGroupId;
        return data; 
    }
}

export interface IGetPresenceGroupDocumentsQuery {
    presenceGroupId?: number;
}

export class RemovePresenceGroupDocumentCommand implements IRemovePresenceGroupDocumentCommand {
    presenceGroupId?: number;
    documentTemplateId?: number;

    constructor(data?: IRemovePresenceGroupDocumentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.presenceGroupId = _data["presenceGroupId"];
            this.documentTemplateId = _data["documentTemplateId"];
        }
    }

    static fromJS(data: any): RemovePresenceGroupDocumentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RemovePresenceGroupDocumentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["presenceGroupId"] = this.presenceGroupId;
        data["documentTemplateId"] = this.documentTemplateId;
        return data; 
    }
}

export interface IRemovePresenceGroupDocumentCommand {
    presenceGroupId?: number;
    documentTemplateId?: number;
}

export class CreateFormCommand implements ICreateFormCommand {
    name?: LanguageString | undefined;
    questions?: CreateQuestionRequest[] | undefined;

    constructor(data?: ICreateFormCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] ? LanguageString.fromJS(_data["name"]) : <any>undefined;
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(CreateQuestionRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateFormCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFormCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateFormCommand {
    name?: LanguageString | undefined;
    questions?: CreateQuestionRequest[] | undefined;
}

export class CreateQuestionRequest implements ICreateQuestionRequest {
    name?: LanguageString | undefined;
    questionType?: QuestionType;
    answersCount?: number | undefined;
    dateQuestionOptions?: AddDateQuestionOptionsRequest | undefined;
    fileQuestionOptions?: AddFileQuestionOptionsRequest | undefined;
    multiChoicesQuestions?: AddMultiChoicesQuestion[] | undefined;

    constructor(data?: ICreateQuestionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] ? LanguageString.fromJS(_data["name"]) : <any>undefined;
            this.questionType = _data["questionType"];
            this.answersCount = _data["answersCount"];
            this.dateQuestionOptions = _data["dateQuestionOptions"] ? AddDateQuestionOptionsRequest.fromJS(_data["dateQuestionOptions"]) : <any>undefined;
            this.fileQuestionOptions = _data["fileQuestionOptions"] ? AddFileQuestionOptionsRequest.fromJS(_data["fileQuestionOptions"]) : <any>undefined;
            if (Array.isArray(_data["multiChoicesQuestions"])) {
                this.multiChoicesQuestions = [] as any;
                for (let item of _data["multiChoicesQuestions"])
                    this.multiChoicesQuestions!.push(AddMultiChoicesQuestion.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateQuestionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateQuestionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        data["questionType"] = this.questionType;
        data["answersCount"] = this.answersCount;
        data["dateQuestionOptions"] = this.dateQuestionOptions ? this.dateQuestionOptions.toJSON() : <any>undefined;
        data["fileQuestionOptions"] = this.fileQuestionOptions ? this.fileQuestionOptions.toJSON() : <any>undefined;
        if (Array.isArray(this.multiChoicesQuestions)) {
            data["multiChoicesQuestions"] = [];
            for (let item of this.multiChoicesQuestions)
                data["multiChoicesQuestions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateQuestionRequest {
    name?: LanguageString | undefined;
    questionType?: QuestionType;
    answersCount?: number | undefined;
    dateQuestionOptions?: AddDateQuestionOptionsRequest | undefined;
    fileQuestionOptions?: AddFileQuestionOptionsRequest | undefined;
    multiChoicesQuestions?: AddMultiChoicesQuestion[] | undefined;
}

export enum QuestionType {
    MultiAnswers = 0,
    OneOfMany = 1,
    DateAnswer = 2,
    FileAnswer = 3,
    TextAnswer = 4,
}

export class AddDateQuestionOptionsRequest implements IAddDateQuestionOptionsRequest {
    isMultiDate?: boolean;
    questionId?: number;

    constructor(data?: IAddDateQuestionOptionsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isMultiDate = _data["isMultiDate"];
            this.questionId = _data["questionId"];
        }
    }

    static fromJS(data: any): AddDateQuestionOptionsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddDateQuestionOptionsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isMultiDate"] = this.isMultiDate;
        data["questionId"] = this.questionId;
        return data; 
    }
}

export interface IAddDateQuestionOptionsRequest {
    isMultiDate?: boolean;
    questionId?: number;
}

export class AddFileQuestionOptionsRequest implements IAddFileQuestionOptionsRequest {
    documentFileType?: DocumentFileType;
    questionId?: number;

    constructor(data?: IAddFileQuestionOptionsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentFileType = _data["documentFileType"];
            this.questionId = _data["questionId"];
        }
    }

    static fromJS(data: any): AddFileQuestionOptionsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddFileQuestionOptionsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentFileType"] = this.documentFileType;
        data["questionId"] = this.questionId;
        return data; 
    }
}

export interface IAddFileQuestionOptionsRequest {
    documentFileType?: DocumentFileType;
    questionId?: number;
}

export enum DocumentFileType {
    PDF = 0,
    Word = 1,
    TxtFile = 2,
}

export class AddMultiChoicesQuestion implements IAddMultiChoicesQuestion {
    choice?: LanguageString | undefined;
    questionId?: number;

    constructor(data?: IAddMultiChoicesQuestion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.choice = _data["choice"] ? LanguageString.fromJS(_data["choice"]) : <any>undefined;
            this.questionId = _data["questionId"];
        }
    }

    static fromJS(data: any): AddMultiChoicesQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new AddMultiChoicesQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["choice"] = this.choice ? this.choice.toJSON() : <any>undefined;
        data["questionId"] = this.questionId;
        return data; 
    }
}

export interface IAddMultiChoicesQuestion {
    choice?: LanguageString | undefined;
    questionId?: number;
}

export class ApplicationResponseOfListOfBasicFormDto implements IApplicationResponseOfListOfBasicFormDto {
    isError?: boolean;
    message?: string | undefined;
    result?: BasicFormDto[] | undefined;

    constructor(data?: IApplicationResponseOfListOfBasicFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(BasicFormDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApplicationResponseOfListOfBasicFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationResponseOfListOfBasicFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IApplicationResponseOfListOfBasicFormDto {
    isError?: boolean;
    message?: string | undefined;
    result?: BasicFormDto[] | undefined;
}

export class BasicFormDto implements IBasicFormDto {
    id?: number;
    name?: LanguageString | undefined;
    uniqueCode?: string | undefined;

    constructor(data?: IBasicFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"] ? LanguageString.fromJS(_data["name"]) : <any>undefined;
            this.uniqueCode = _data["uniqueCode"];
        }
    }

    static fromJS(data: any): BasicFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new BasicFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        data["uniqueCode"] = this.uniqueCode;
        return data; 
    }
}

export interface IBasicFormDto {
    id?: number;
    name?: LanguageString | undefined;
    uniqueCode?: string | undefined;
}

export class GetFormsQuery implements IGetFormsQuery {

    constructor(data?: IGetFormsQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetFormsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetFormsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IGetFormsQuery {
}

export class EditFormCommand extends CreateFormCommand implements IEditFormCommand {
    id?: number;

    constructor(data?: IEditFormCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EditFormCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditFormCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data; 
    }
}

export interface IEditFormCommand extends ICreateFormCommand {
    id?: number;
}

export class RemoveFormCommand implements IRemoveFormCommand {
    id?: number;

    constructor(data?: IRemoveFormCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RemoveFormCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveFormCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IRemoveFormCommand {
    id?: number;
}

export class CreateDocumentTemplateCommand implements ICreateDocumentTemplateCommand {
    name?: LanguageString | undefined;
    documentTemplateTypeId?: number;
    documentTemplateFileTypes?: DocumentFileType[] | undefined;
    hasValidationDate?: boolean;
    forms?: number[] | undefined;

    constructor(data?: ICreateDocumentTemplateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] ? LanguageString.fromJS(_data["name"]) : <any>undefined;
            this.documentTemplateTypeId = _data["documentTemplateTypeId"];
            if (Array.isArray(_data["documentTemplateFileTypes"])) {
                this.documentTemplateFileTypes = [] as any;
                for (let item of _data["documentTemplateFileTypes"])
                    this.documentTemplateFileTypes!.push(item);
            }
            this.hasValidationDate = _data["hasValidationDate"];
            if (Array.isArray(_data["forms"])) {
                this.forms = [] as any;
                for (let item of _data["forms"])
                    this.forms!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateDocumentTemplateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDocumentTemplateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        data["documentTemplateTypeId"] = this.documentTemplateTypeId;
        if (Array.isArray(this.documentTemplateFileTypes)) {
            data["documentTemplateFileTypes"] = [];
            for (let item of this.documentTemplateFileTypes)
                data["documentTemplateFileTypes"].push(item);
        }
        data["hasValidationDate"] = this.hasValidationDate;
        if (Array.isArray(this.forms)) {
            data["forms"] = [];
            for (let item of this.forms)
                data["forms"].push(item);
        }
        return data; 
    }
}

export interface ICreateDocumentTemplateCommand {
    name?: LanguageString | undefined;
    documentTemplateTypeId?: number;
    documentTemplateFileTypes?: DocumentFileType[] | undefined;
    hasValidationDate?: boolean;
    forms?: number[] | undefined;
}

export class GetDocumentTemplateTypesQuery implements IGetDocumentTemplateTypesQuery {

    constructor(data?: IGetDocumentTemplateTypesQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetDocumentTemplateTypesQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetDocumentTemplateTypesQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IGetDocumentTemplateTypesQuery {
}

export class EditDocumentTemplateCommand extends CreateDocumentTemplateCommand implements IEditDocumentTemplateCommand {
    id?: number;

    constructor(data?: IEditDocumentTemplateCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EditDocumentTemplateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditDocumentTemplateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data; 
    }
}

export interface IEditDocumentTemplateCommand extends ICreateDocumentTemplateCommand {
    id?: number;
}

export class RemoveDocumentTemplateCommand implements IRemoveDocumentTemplateCommand {
    id?: number;

    constructor(data?: IRemoveDocumentTemplateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RemoveDocumentTemplateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveDocumentTemplateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IRemoveDocumentTemplateCommand {
    id?: number;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}